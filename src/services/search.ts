import { Cet6Word } from './cet6';
export type SearchMode = 'normal' | 'fuzzy' | 'regex';
export interface SearchOptions { mode: SearchMode; root: boolean; limit?: number; }
export interface SearchResultItem { word: Cet6Word; score: number; highlights?: number[]; }
const SUFFIXES = ['ing', 'ed', 'es', 's', 'ly', 'er', 'est', 'ment', 'tion', 'ions', 'al', 'ive', 'ous', 'able', 'ible'];
function stem(token: string): string { let t = token.toLowerCase(); for (const suf of SUFFIXES) { if (t.endsWith(suf) && t.length - suf.length >= 3) return t.slice(0, -suf.length); } return t; }
interface IndexEntry { word: Cet6Word; grams: Set<string>; }
let index: IndexEntry[] = []; let builtForCount = 0;
export function buildIndex(words: Cet6Word[]) { if (words.length === builtForCount) return; index = words.map(w => ({ word: w, grams: grams(w.word) })); builtForCount = words.length; }
function grams(text: string): Set<string> { const g = new Set<string>(); const s = text.toLowerCase(); for (let i = 0; i < s.length - 1; i++) g.add(s.slice(i, i + 2)); return g; }
function fuzzyScore(a: string, b: string): number { if (a === b) return 100; const ga = grams(a), gb = grams(b); let inter = 0; ga.forEach(g => { if (gb.has(g)) inter++; }); const shared = inter / Math.max(1, Math.min(ga.size, gb.size)); const dist = lev(a, b); return shared * 50 - dist * 5; }
export function advancedSearch(words: Cet6Word[], query: string, opts: SearchOptions): SearchResultItem[] { const q = query.trim(); if (!q) return words.slice(0, opts.limit || 500).map(w => ({ word: w, score: 0 })); buildIndex(words); let results: SearchResultItem[] = []; if (opts.mode === 'regex') { let reg: RegExp | null = null; try { reg = new RegExp(q.replace(/^\/(.*)\/([gimuy]*)$/, '$1'), q.endsWith('/') ? undefined : 'i'); } catch { return []; } for (const e of index) { if (reg!.test(e.word.word) || reg!.test(e.word.translation)) results.push({ word: e.word, score: 50 }); } } else if (opts.mode === 'normal') { const stemmed = opts.root ? stem(q) : q.toLowerCase(); for (const e of index) { const w = e.word.word.toLowerCase(); const trans = e.word.translation.toLowerCase(); if (w.includes(q.toLowerCase()) || trans.includes(q.toLowerCase()) || (opts.root && w.startsWith(stemmed))) { const highlights: number[] = []; const pos = w.indexOf(q.toLowerCase()); if (pos >= 0) highlights.push(pos); results.push({ word: e.word, score: 80 - (pos >= 0 ? pos : 40), highlights }); } } } else { const stemmed = opts.root ? stem(q) : q.toLowerCase(); const gq = grams(stemmed); const candidates: IndexEntry[] = []; for (const e of index) { const w = e.word.word.toLowerCase(); if (w[0] === stemmed[0]) { candidates.push(e); continue; } let ok = false; for (const g of gq) { if (e.grams.has(g)) { ok = true; break; } } if (ok) candidates.push(e); } for (const e of candidates) { const w = e.word.word.toLowerCase(); let base = w; if (opts.root) base = stem(w); const s = fuzzyScore(stemmed, base); if (s > -20) results.push({ word: e.word, score: s }); } } results.sort((a, b) => b.score - a.score); if (opts.limit) results = results.slice(0, opts.limit); return results; }
function lev(a: string, b: string) { const m = a.length, n = b.length; const dp = new Array(m + 1); for (let i = 0; i <= m; i++) { dp[i] = new Array(n + 1); dp[i][0] = i; } for (let j = 0; j <= n; j++) dp[0][j] = j; for (let i = 1; i <= m; i++) for (let j = 1; j <= n; j++) { const cost = a[i - 1] === b[j - 1] ? 0 : 1; dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost); } return dp[m][n]; }
